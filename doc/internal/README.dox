/**
\page readme README

\section _description Description

  The WHT package exists for mostly for pedagogical purposes and serves as a 
  reference model for exploring and experimenting with 
  architecture specific optimizations.

  This package is a modified version of the Spiral WHT 1.8 package:

  \par
    http://www.spiral.net/software/wht.html

  \attention 
  It is presently a prelease, and some features and data structures will change
  before the next release.
  

\section _background Background
  This package has been created as part of the SPIRAL project:

  \par
    http://www.spiral.net

  The SPIRAL project pursues the goal of automating the implementation, 
  optimization, and platform adaptation of digital signal
  processing (DSP) algorithms.   

  The original design of this package was based on an FFT package 
  by Sebastian Egner:

  \par
   http://avalon.ira.uka.de/home/egner

  The latest version incorporates a more modular design based on the FFTW package
  by Matteo Frigo, and Steven G. Johnson:

  \par
    http://www.fftw.org

  It is possible to use native hardware performance counters using 
  the PAPI library:

  \par
    http://icl.cs.utk.edu/papi

\section _authors Authors
  See the \ref authors file which is distributed with this package.

\section _copyright Copyright
  See the \ref copying and \ref copyright files which are distributed with this package.

\section _install Installation
  See the \ref install file which is distributed with this package.

\section _demo Getting Started
  Once you have configured and compiled the package, several programs will be available to you.

\subsection _verify Verify
  This program accepts as input a WHT plan and empyrically determines, through 
  direct calculation, whether or not the plan is:

  -# In the langauge accepted by the library.
  -# Numerically correct

  To execute this program try:
  \code
  $ wht_verify -w 'small[1]'
  $ wht_verify -w 'split[small[2],small[3]]'
  $ wht_verify -w 'split[]'
  \endcode

  The last invocation should fail since it is not a string accepted by the grammar.

\subsection _measure Measure
  This program measures some metric against the execution of a WHT plan.  
  By default this utility can measure running time in microseconds.  If configured to use the 
  PAPI library, all performance counters available on your architecture can be measured.

  To execute this program try:
  \code
  $ wht_measure -w 'split[small[4],small[4]]' -t 2.0
  \endcode

  This will run execute the plan until it has spent a total of 2 seconds executing and 
  print the average computation time in microseconds.

  If you have PAPI, try these parameters:
  \code
  $ wht_measure -w 'split[small[4],small[4]]' -e PAPI -m TOT_CYC -a 99.5 -p 1 -k 10
  \endcode

  This will count the average number of cycles it takes the plan to execute.  
  The alpha parameter (-a)  and rho parameter (-p) specify that the number of samples should 
  be such that the measured mean is within 1 % of the true mean with 99.5 % confidence.  
  The run parameter (-k) specifies that 10 runs are average and considered a single sample.

\subsection _rand Random Plans
  This program generates random WHT plans given a set of constraints.  To be specific, 
  all trees generated by this program are Uniform Level,  Bernoulli Recursive.  
  That is, for each integer composition within the constraints, we assume that each is 
  equally likely to occur.  If the integer composition can be factored into another 
  integer composition, we recursively apply the algorithm.  
  If the integer could be factor but could also remain as a leaf node, we flip a coin to 
  determine if the algorithm should be recursively applied.

  To execute this program try:
  \code
  $ wht_randtree -n 8 -a 2 -b 4
  \endcode

  This generates a random WHT trees of order 8, with 2 to 4 children at level.

\subsection _convert Convert
  This program applies code transformations to a given WHT plan to produce a new plan.  

  If you have enabled interleaveding try:
  \code
  $ wht_convert -w 'split[small[2],small[2]]' -t 'splitil[small[0]]' | wht_convert -t 'smallil(2)[0]'
  \endcode

  This first transforms the split codelet into a split interleaved codelet, 
  and then interleaves all codelets by 2 if this operation is allowed.


\section _maintainers Maintainers
  A set of tools hidden from normal users is available for those who wish to 
  further develop the package.

  To rebuild the autotools build system type:
  \code
  ./autogen.sh
  \endcode

  To rebuild the documentation, including this \ref readme file, type:
  \code
  ./autodoc.sh
  \endcode

  All non code internal documentation, including this \ref readme file, should go in
  doc/internal.  All non code external documentation, for instance \ref
  measure_extension "instructions to add a new measurement extension", should
  go in doc/external.

  Various developer related features are enabled by configuring with 
  the maintainer mode flag:

  \code
  ./configure --enable-maintainer-mode ...
  \endcode

  Adding new codelets to the system:
  \see wht/registry.h
  \see \ref wht_Makefile_am

  Adding new code generators to the system:
  \see whtgen/whtgen.c
  \see \ref wht_Makefile_am
  \see whtgen/whtgen-simd

  Adding generated code to the system:
  \see wht/codelets/register_codelets.pl
  \see wht/codelets/make_small_codelets.sh
  \see wht/codelets/make_interleave_codelets.sh
  \see wht/codelets/make_simd_codelets.sh
  \see \ref wht_Makefile_am

  When submiting a patch please use:
  \code
  diff -Naur spiral_wht-2.0 my_source_tree | gzip > my_patch.txt.gz
  \endcode

\section _publications Publications
  - About the original WHT package:
    - Jeremy Johnson and Markus Pueschel.
      In Search of the Optimal Walsh-Hadamard Transform.
      Proc. ICASSP 2000, pp. 3347-3350.

  - About DDL:
    - Neungsoo Park and Viktor Prasanna.
      Cache Conscious Walsh-Hadamard Transform.
      Proc. ICASSP 2001, Vol. II.

  - About Loop Interleaving:
     - K. S. Gatlin and L. Carter.
       Faster FFTs via Architecture-Cognizance.
       Proc. PACT, 2000.

  - About Parallelization with openMP:
    - Kang Chen and Jeremy Johnson.
      A Prototypical Self-Optimization Package for Parallel Implementation of Fast.
      Signal Transforms. IPDPS 2002.

  - About Performance Analysis:
    - Michael Andrews and Jeremy Johnson.  
      Performance Analysis of a Family of WHT Algorithms.  
      IPDPS 2007.

*/
