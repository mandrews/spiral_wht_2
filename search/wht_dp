#!/usr/bin/env ruby

# wht_dp
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$
#
# TODO
#   - Input for selecting possible transforms

SCRIPT_PATH       = File.dirname(__FILE__) 
SCRIPT_NAME       = 'wht_dp'
DEFAULT_PARAMS    = {
  :min_size       => 1,
  :max_size       => 15,
  :max_children   => 2,
  :measure        => SCRIPT_PATH + '/wht_measure',
  :best_trees     => SCRIPT_PATH + '/../share/wht_best_trees.txt',
  :subspace       => nil,
  :transforms     => nil,
}

$LOAD_PATH << "#{SCRIPT_PATH}/../extra"

require "utils"

class Options
  require 'optparse'
  attr_reader :params
  def initialize
    @params  = DEFAULT_PARAMS
    @options = OptionParser.new do |o|
      o.banner = "Usage: #{SCRIPT_NAME} [OPTIONS]"
      o.separator ""
      o.on("-h", "--help", 
        "Show this help message.") { 
        die }

      o.on("-v", "--verbose", 
        "Show non-essential information.") {
        @params[:verbose] = true }

      o.on("-a", "--min-size=SIZE", Integer,
        "Start the search at size 2^SIZE.") { |x|
        @params[:min_size] = x }

      o.on("-b", "--max-size=SIZE", Integer,
        "Stop the search at size 2^SIZE.") { |x|
        @params[:max_size] = x }

      o.on("-k", "--max-children=CHILDREN", Integer,
        "Maximum number of children to allow on a split node.") { |x|
        @params[:max_children] = x }

      o.on("-s", "--subspace=SPACE", String,
        "Confine search to SPACE (presently only RIGHT supported).") { |x|
        @params[:subspace] = x }

      o.on("-m", "--wht-measure=FILE", 
        "Program to measure peformance of WHT tree.") { |x|
         @params[:measure] = x }

      o.on("-t", "--transformations='A,B,C, ... '", 
        "Apply the following code transformations to the WHT tree.") { |x|
         @params[:transforms] = x }

      o.on("-f", "--wht-best-trees=FILE", String,
        "File to load/store the best trees found by dynamic programming.") { |x|
         @params[:best_trees] = x }
    end
  end

  def die(msg = nil)
    puts @options.to_s 
    puts "\n#{msg}" unless msg.nil?
    exit
  end

  def parse(args)
    begin
      @options.parse!(args)
    rescue => e
      die(e.message)
    end
  end

end

class Search
  INF = 1.0 / 0.0
  attr_accessor :best
  attr_accessor :debug
  def initialize(params)
    @min_size       = params[:min_size]
    @max_size       = params[:max_size]
    @max_children   = params[:max_children]
    @measure        = params[:measure]
    @il_max         = params[:il_max]
    @vsize          = params[:vsize]
    @max_leaf       = params[:max_leaf]
    @subspace       = params[:subspace]
    @debug          = params[:debug]

    @best = {}

    for size in 1 .. @max_size do 
      @best[size.to_s] ||= { 'time' => INF, 'plan' => nil, 'oid' => 0}
    end
  end

  def best=(map)
    map.each do |k,v|
      @best[k] = map[k]
    end
  end

  def run
    for size in @min_size .. @max_size do 
      puts "size #{size}" if @debug
      find(size)
    end
  end

  def measure(plan)
    cmd = "#{@measure} -w '#{plan}'"
    puts "Executing #{cmd}" if @debug
    t = 0
    IO.popen(cmd) do |fd|
      t = fd.gets
    end

    unless t 
      puts("Could not read: #{cmd}") if @debug
      return INF
    else
      t.to_f
    end
  end

  def find(size)
    plans = []

    operation = lambda do |zp|
      next if zp.first == size and size > @max_leaf
      plan = zp_to_plan(zp)

      plans << plan
      #plans << `#{SCRIPT_PATH}/../wht/wht_convert -w #{plan} -i 8 -v 2`.chomp!
    end

    case @subspace 
      when 'right'
        g_cp_n_right(size, 1, @max_children, @max_size) { |zp| operation.call(zp) }
      else
        g_cp_n(size, 1, @max_children) { |zp| operation.call(zp) }
    end

    plans.each do |p|
      t  = measure(p)
      tp = @best[size.to_s]['time']
      if t < tp
        puts "New Best for #{size} with T=#{t} (T'=#{tp}): #{p}"
        @best[size.to_s]['time'] = t
        @best[size.to_s]['plan'] = p
        @best[size.to_s]['oid']  = size
        @best[size.to_s]['transform']  = 'none'
      end
    end
  end

  def find_best(size)
    unless @best[size.to_s]['plan']
      find(size)
    end
    @best[size.to_s]['plan']
  end

  def zp_to_plan(zp)
    s = []
    zp.each do |z|
      if z > @max_leaf
        s << find_best(z)
      else
        s << "small[#{z}]"
      end
    end

    if s.size > 1
      return "split[" + s.join(',') + "]"
    else
      return s.first
    end
  end
end

# To generate compositions with elements >= MIN
#   1) verify that MIN | n i.e n % min == 0
#   2) set m = n / MIN, and generate compositions
#   3) multiply each m_i by MIN
#
# Similarly for elements <= MAX

# Generate (enumerate) all k combinations of n
# See http://home.att.net/~srschmitt/script_combinations.html
def g_k_cb_n(n,k)
  a = (1..k).to_a

  loop do
    yield a

    i = k - 1
    while a[i] == (n - k + i + 1) do
      i -= 1
    end

    return if (i < 0)

    a[i] += 1

    for j in i+1 .. k-1 do
      a[j] = a[i] + j - i
    end
  end
end

# Generate (enumerate) all k combinations of n
# given that the trees are rightmost
# See above
def rightmost(a,max)
  b = a.dup
  b.pop # Do not consider last element
  c = b.select { |x| x <= max }
  return (c.size == b.size)
end

def g_k_cb_n_right(n,k,max)
  a = (1..k).to_a

  loop do
    yield a if rightmost(a, max)

    i = k - 1
    while a[i] == (n - k + i + 1) do
      i -= 1
    end

    return if (i < 0)

    a[i] += 1

    for j in i+1 .. k-1 do
      a[j] = a[i] + j - i
    end
  end
end

# Map a combination to a composition
# Idea from Dr. Johnson
# see http://en.wikipedia.org/wiki/Combinadic
def map_cb_to_cp(n, cb)
  m, i = 0, 0
  cp = Array.new(cb.size)
  cb.each do |x|
    cp[i] = x - m
    m = x
    i += 1
  end
  cp[i] = n - m
  cp
end

# Generate (enumerate) all k-way compositions of n forall k in a..b
def g_cp_n(n, a, b)
  max = [n, b].min
  a.upto(max) do |k|
    g_k_cb_n(n-1,k-1) do |cb|
      yield map_cb_to_cp(n,cb)
    end
  end
end

# Generate (enumerate) all k-way compositions of n forall k in a..b
# given that the trees are rightmost
def g_cp_n_right(n, a, b, m)
  max = [n, b].min
  a.upto(max) do |k|
    g_k_cb_n_right(n-1,k-1,m-1) do |cb|
      yield map_cb_to_cp(n,cb)
    end
  end
end

if $0 == __FILE__ # Main Entry Point
  opts = Options.new
  opts.parse(ARGV)

  unless File.exists?(opts.params[:measure].split.first)
    opts.die("Could find measure #{opts.params[:measure]}")
  end

  env = load_runtime_env

  dp = Search.new(
    { :min_size       => opts.params[:min_size],
      :max_size       => opts.params[:max_size],
      :max_children   => opts.params[:max_children],
      :max_leaf       => env['max_unroll'],
      :il_max         => env['max_interleave'],
      :vsize          => env['vector_size'],
      :debug          => opts.params[:verbose],
      :measure        => opts.params[:measure],
      :subspace       => opts.params[:subspace],
      :transforms     => opts.params[:transforms],
    } )

  best_trees = opts.params[:best_trees] 

  info, trees = load_data(best_trees, env)

  dp.best = trees

  dp.run

  save_data(best_trees, env, dp.best, info)
end

