#!/usr/bin/env ruby

# whtgen.rb
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$

IDENT   = "  "

@stack  = []
@tmp    = 0

def l_2v_v(x,a,s,y,b,t,v)
  case v
    when 1 # Transform undefined, just copy input to output
      y[b],y[b+t] = x[a],x[a+s]
    when 2 
      t1,t2 = mk_tmp(2)
      @stack.push shuf(t1,x[a],x[a+s],[0,0],v)
      @stack.push shuf(t2,x[a],x[a+s],[1,1],v)
      y[b],y[b+t] = t1,t2
    when 4
      t1,t2 = mk_tmp(2)
      @stack.push shuf(t1,x[a],x[a+s],[0,1,0,1],v)
      @stack.push shuf(t2,x[a],x[a+s],[2,3,2,3],v)
      @stack.push shuf(t1,t1,t1,[0,2,1,3],v)
      @stack.push shuf(t2,t2,t2,[0,2,1,3],v)
      y[b],y[b+t] = t1,t2
  end
end

def wht_2v(n,x,a,s,y,b,t,v)
  p,q,r = {}, {}, {}
  m = n/2
  wht_2(x,a,s,p,b,t,v)

  l_2v_v(p,a,s,q,b,t,v)

  wht(v,q,a,s,r,b,t,v)

  l_2v_v(r,a,s,y,b,t,v)
end

def wht_2(x,a,s,y,b,t,v)
  t1,t2 = mk_tmp(2)
  @stack.push add(t1,x[a],x[a+s],v)
  @stack.push sub(t2,x[a],x[a+s],v)
  y[b],y[b+t] = t1,t2
end

def wht(n,x,a,s,y,b,t,v)
  if n < 2 # Transform undefined, just copy input to output
    y[b],y[b+s] = x[a],x[a+s]
  elsif n == 2
    wht_2(x,a,s,y,b,t,v)
  elsif n == 2*v
    wht_2v(n,x,a,s,y,b,t,v)
  else
    z = {}
    m = n/2
    wht(m,x,a,s,z,b,t,v)
    wht(m,x,a+(m/v),s,z,b+(m/v),t,v)
    for i in 0 .. (m/v)-1 do
      wht_2(z,a+i,(m/v)*s,y,b+i,(m/v)*t,v)
    end
  end
end

def add(r,a,b,v)
  { :type => :add,   :out => r, :in => [a,b], :vsize => v }
end

def sub(r,a,b,v)
  { :type => :sub,   :out => r, :in => [a,b], :vsize => v }
end

def load(r,m,s,v)
  { :type => :load,  :out => r, :in => [m,s], :vsize => v }
end

def store(r,m,s,v)
  { :type => :store, :out => r, :in => [m,s], :vsize => v }
end

def shuf(r,a,b,m,v)
  # TODO assert m.size = v
  { :type => :shuf,  :out => r, :in => [a,b], :vsize => v, :mask => m}
end

def mk_tmp(k)
  a = []
  k.times do
    a << @tmp += 1
  end
  a
end

def vectorize(v,p)
  p.each do |x|
    x[:vsize] = v
  end
end

def scalar_stack_to_string p
  s = ""
  p.each do |x|
    r,a,b = x[:out],x[:in][0],x[:in][1]
    s += IDENT
    s += case x[:type]
      when :add   then "t#{r} = t#{a} + t#{b};\n"
      when :sub   then "t#{r} = t#{a} - t#{b};\n"
      when :load  then "t#{r} = #{a}[#{b}];\n"
      when :store then "#{a}[#{b}] = t#{r};\n"
      else "/* undefined. */\n"
    end
  end
  s
end

def vector_stack_to_string p
  s = ""
  p.each do |x|
    r,a,b,v,m = x[:out],x[:in][0],x[:in][1],x[:vsize],x[:mask]
    s += IDENT
    s += case x[:type]
      when :add   then "vadd#{v}(t#{r},t#{a},t#{b});\n"
      when :sub   then "vsub#{v}(t#{r},t#{a},t#{b});\n"
      when :load  then "vload#{v}(t#{r},#{a}[#{b}]);\n"
      when :store then "vstore#{v}(t#{r},#{a}[#{b}]);\n"
      when :shuf  then "vshuf#{v}(t#{r},t#{a},t#{b},#{m.join(',')});\n"
      else "/* undefined. */\n"
    end
  end
  s
end

def die(msg)
  puts msg
  exit 1
end

# Main entry point 

class Options
  require 'optparse'
  attr_reader :params
  def initialize
    @params = {}
    @params[:n] = nil
    @params[:v] = 1
    @params[:a] = false
    @params[:i] = 1
    @options = OptionParser.new do |o|
      o.banner = "Usage: #{$0} [OPTIONS]"
      o.separator ""
      o.on("-h", "--help", 
        "Show this help message.") { die }

      o.on("-v", "--vector_size=SIZE", Integer,
        "Vector size.") { |x| @params[:v] = x.to_i }

      o.on("-n", "--wht_size=SIZE", Integer,
        "Size of WHT to unroll.") { |x| @params[:n] = x.to_i } 

      o.on("-a", "--aligned", 
        "Access aligned memory, i.e. at unit stride.") { |x| @params[:a] = true }

      o.on("-i", "--interleave=FACTOR", Integer,
        "Loop interleaving factor.") { |x| @params[:i] = x.to_i } 
    end
  end

  def die(msg = nil)
    puts @options.to_s 
    puts "\n#{msg}" unless msg.nil?
    exit
  end

  def parse(args)
    begin
      @options.parse!(args)
    rescue => e
      die(e.message)
    end

    die unless @params[:n]

    @params[:n] = 2**@params[:n]
    unless @params[:n] > @params[:v]
      die("Size must be greater than vector size.")
    end
  end

end

opts = Options.new
opts.parse(ARGV)

n = opts.params[:n]
v = opts.params[:v]
il = opts.params[:i]
m = (Math.log(n) / Math.log(2)).to_i
a = opts.params[:a] ? "" : "*S"

x = {}
y = {}

(n/v).times do |i| 
  t = mk_tmp(1)
  x[i] = t
  @stack.push  load(t,"x",(i*v).to_s + a,v)
end

wht(n,x,0,1,y,0,1,v)

(n/v).times do |i| 
  t = y[i] 
  @stack.push store(t,"x",(i*v).to_s + a,v)
end

aligned = opts.params[:a] ? "_a" : ""

if v > 1
  type = "wht_vector#{v}" 
  name = "apply_small#{m}_v#{v}" + aligned
  body = vector_stack_to_string(@stack) 
elsif il > 1
  type = "wht_vector#{il}" 
  name = "apply_small#{m}_il#{il}"
  body = vector_stack_to_string(vectorize(il,@stack)) 
else
  type = "wht_value"
  name = "apply_small#{m}" + aligned
  body = scalar_stack_to_string(@stack) 
end

header = "#include \"wht.h\"\n\n" +
         "void #{name}(Wht *W, long S, long D, wht_value *x)\n{\n"

decls = ""
@tmp.times do |i|
  decls += IDENT + type + " t#{i+1};\n"
end

puts header + decls + body + "}\n"
