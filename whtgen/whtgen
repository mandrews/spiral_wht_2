#!/usr/bin/env ruby

# whtgen.rb
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$
#
# TODO increment ref count when tmp is input
#      decrement ref count when tmp is output
#      reuse tmps that have 0 ref count


SCRIPT_PATH     = File.dirname(__FILE__) 
SCRIPT_NAME     = 'whtgen'
INDENT          = "  "

class Options
  require 'optparse'
  attr_reader :params
  attr_reader :options
  def initialize

    @params = {
      :size             => nil,
      :vector_size      => 1,
      :interleave_by    => 1,
      :aligned          => false,
    }

    @options = OptionParser.new do |o|
      o.banner = "Usage: #{SCRIPT_NAME} [OPTIONS]"
      o.separator ""
      o.on("-h", "--help", 
        "Show this help message.") { puts @options.to_s; exit }

      o.on("-n", "--wht-size=SIZE", Integer,
        "Size of WHT to unroll.") { |x| @params[:size] = x.to_i } 

      o.on("-v", "--vector-size=SIZE", Integer,
        "Vector size.") { |x| @params[:vector_size] = x.to_i }

      o.on("-i", "--interleave-by=FACTOR", Integer,
        "Loop interleaving factor.") { |x| @params[:interleave_by] = x.to_i } 

      o.on("-a", "--aligned", 
        "Access aligned memory, i.e. at unit stride.") { |x| @params[:aligned] = true }

    end
  end
end

def log2(n)
  (Math.log(n) / Math.log(2)).to_i
end

def l_mn_m(m,n)
  p = []
  for i in 0 .. (m-1) do
    for j in 0 .. (n-1) do
      p << (j*m)+i
    end
  end
  p
end

def permute(n,x,a,s,y,b,t,v,sign)
  p = l_mn_m(n/2,2)
   
  t1,t2 = mk_tmp(2)
  if    p ==  [0,2,1,3] and v == 2
    @stack.push Shuf.new(t1,x[a],x[a+s],[0,0],v)
    @stack.push Shuf.new(t2,x[a],x[a+s],[1,1],v)
  elsif p ==  [0,2,1,3] and v == 4
    @stack.push Shuf.new(t1,x[a],x[a+s],[0,1,0,1],v)
    @stack.push Shuf.new(t2,x[a],x[a+s],[2,3,2,3],v)
  elsif p ==  [0,4,1,5,2,6,3,7] and v == 4 and sign > 0
    @stack.push Shuf.new(t1,x[a],x[a+s],[0,1,0,1],v)
    @stack.push Shuf.new(t2,x[a],x[a+s],[2,3,2,3],v)
    @stack.push Shuf.new(t1,t1,t1,[0,2,1,3],v)
    @stack.push Shuf.new(t2,t2,t2,[0,2,1,3],v)
  elsif p ==  [0,4,1,5,2,6,3,7] and v == 4 and sign < 0
    @stack.push Shuf.new(x[a],x[a],x[a],[0,2,1,3],v)
    @stack.push Shuf.new(x[a+s],x[a+s],x[a+s],[0,2,1,3],v)
    @stack.push Shuf.new(t1,x[a],x[a+s],[0,1,0,1],v)
    @stack.push Shuf.new(t2,x[a],x[a+s],[2,3,2,3],v)
  end
  y[b],y[b+t] = t1,t2
end

def wht_2v(n,x,a,s,y,b,t,v)
  p,q,r = {}, {}, {}
  m = n/2
  wht_2(x,a,s,p,b,t,v)

  permute(n,p,a,s,q,b,t,v,+1)

  if m > 2
    wht_2v(m,q,a,s,r,b,t,v)
  else
    wht_2(q,a,s,r,b,t,v)
  end

  permute(n,r,a,s,y,b,t,v,-1)
end

def wht_2(x,a,s,y,b,t,v)
  t1,t2 = mk_tmp(2)
  @stack.push Add.new(t1,x[a],x[a+s],v)
  @stack.push Sub.new(t2,x[a],x[a+s],v)
  y[b],y[b+t] = t1,t2
end

def wht(n,x,a,s,y,b,t,v)
  if n < 2 # Transform undefined, just copy input to output
    y[b],y[b+s] = x[a],x[a+s]
  elsif n == 2
    wht_2(x,a,s,y,b,t,v)
  elsif n == 2*v
    wht_2v(n,x,a,s,y,b,t,v)
  else
    z = {}
    m = n/2
    wht(m,x,a,s,z,b,t,v)
    wht(m,x,a+(m/v),s,z,b+(m/v),t,v)

    for i in 0 .. (m/v)-1 do
      wht_2(z,a+i,(m/v)*s,y,b+i,(m/v)*t,v)
    end
  end
end

class BinIns
  attr_accessor :v
  def initialize(r,a,b,v)
    @r,@a,@b,@v = r,a,b,v
    @t = 'ta'
    @@stride = false
  end

  def interleave(k, stride = false)
    @@stride = stride
    k.times { @t = @t.succ }
  end

  def tmps
    [(sprintf "%s%d",@t,@r),
     (sprintf "%s%d",@t,@a), 
     (sprintf "%s%d",@t,@b), ]
  end
end

class Add < BinIns
  def to_s
    if @v < 2 
      "#{@t}#{@r} = #{@t}#{@a} + #{@t}#{@b};\n"
    else
      "vadd#{@v}(#{@t}#{@r},#{@t}#{@a},#{@t}#{@b});\n"
    end
  end
end

class Sub < BinIns
  def to_s
    if @v < 2 
      "#{@t}#{@r} = #{@t}#{@a} - #{@t}#{@b};\n"
    else
      "vsub#{@v}(#{@t}#{@r},#{@t}#{@a},#{@t}#{@b});\n"
    end
  end
end

class Shuf < BinIns
  def initialize(r,a,b,m,v)
    # TODO assert m.size = v
    super(r,a,b,v)
    @m = m
  end

  def to_s
    if @v < 2 
      "/* undefined*/;\n"
    else
      "vshuf#{@v}(#{@t}#{@r},#{@t}#{@a},#{@t}#{@b},#{@m.join(',')});\n"
    end
  end
end

class MemIns
  attr_accessor :v
  def initialize(r,m,s,a,v)
    @r,@m,@s,@a,@v = r,m,s,a,v
    @k = 0
    @t = 'ta'
    @@stride = false
  end

  def interleave(k, stride = false)
    @@stride = stride
    @k = k
    k.times { @t = @t.succ }
  end

  def stride
    if @@stride
      @a ? "#{@s+@k} * S" : "(#{@s} * S) + (#{@k} * U)"
    else
      @a ? "#{@s+@k}" : "(#{@s} * S) + #{@k}"
    end
  end

  def tmps
    [(sprintf "%s%d",@t,@r)]
  end
end

class Load < MemIns
  def to_s
    if @v < 2 
      sprintf "%s%d = %s[%s];\n",@t,@r,@m,stride
    else
      sprintf "vload%d(%s%d,%s[%s]);\n",@v,@t,@r,@m,stride
    end
  end
end

class Store < MemIns
  def to_s
    if @v < 2 
      sprintf "%s[%s] = %s%d;\n",@m,stride,@t,@r
    else
      sprintf "vstore%d(%s%d,%s[%s]);\n",@v,@t,@r,@m,stride
    end
  end
end

class Generator
  def initialize(n,i,v,vp,a,type,name)
    @n,@i,@v,@vp,@a,@type,@name = n,i,v,vp,a,type,name
    @stack  = []
    @tmp    = 0
  end

  def mk_tmp(k=1)
    return @tmp += 1 unless k > 1

    a = []
    k.times do
      a << @tmp += 1
    end
    a
  end

  def compile_guard
    g = []
    g << "(#{log2(@n)} <= WHT_MAX_UNROLL)"
		g << "(#{log2(@i)} <= WHT_MAX_INTERLEAVE)" if @i > 1
		g << "(#{@vp} == WHT_VECTOR_SIZE)"   if @vp > 1
    "#if " + g.join(" && ") + "\n"
  end

  def to_s
    body = ""
    tmps = []
    @stack.each do |x|
      body += INDENT + x.to_s
      tmps += x.tmps
    end

    a = @a ? '_a' : ''

    header  = "#include \"wht.h\"\n\n" +
              "void #{@name}#{a}(Wht *W, long S, size_t U, wht_value *x)\n{\n"

		header += compile_guard

    decls = ""
    tmps.uniq.each do |t|
      decls += sprintf "%s%s %s;\n",INDENT, @type, t
    end

    footer  = ""
    footer += "#else\n   wht_error(\"initialization guards should prevent this message\");\n" 
		footer += "#endif\n"
    header + decls + body + footer + "}\n"
  end

  def interleave(stride = false)
    q = []
    @stack.each do |x|
      q << x.clone
      for k in 1 .. @i-1 do # Make i copies
        y = x.clone
        y.interleave(k, stride)
        q << y
      end
    end
    @stack = q
  end

  def vectorize(v)
    p = []
    (0..@stack.size-1).step(v) do |i|
      x = @stack[i]
      x.v = v
      p << x
    end
    @stack = p
  end

  def run
    x = {}
    y = {}

    @n.times do |i| 
      t = mk_tmp
      x[i] = t
      @stack.push  Load.new(t,"x",(i*@v),@a,@v)
    end

    wht(@n*@v,x,0,1,y,0,1,@v)

    @n.times do |i| 
      t = y[i] 
      @stack.push Store.new(t,"x",(i*@v),@a,@v)
    end

  end
end

def die(msg)
  puts msg
  exit
end

def parse_opts(opts, args)
  begin
    opts.options.parse!(args)
  rescue => e
    die(e.message)
  end
end

def check_opts(opts)
  die(" -n SIZE required") unless opts.params[:size]

  k = opts.params[:interleave_by] * (2**opts.params[:size]) 
  v = opts.params[:vector_size]

  unless k > v
    die("SIZE x INTERLEAVED_BY must be greater than VECTOR_SIZE")
  end

end

# Main entry point 
if $0 == __FILE__ 
  opts = Options.new

  parse_opts(opts, ARGV)

  m = opts.params[:size]
  v = opts.params[:vector_size]
  i = opts.params[:interleave_by]
  a = opts.params[:aligned] 

  check_opts(opts)

  n = 2**m

  if v > 1 and i > 1 
    g = Generator.new(n,i,1,v,a,
      "wht_vector#{v}", "apply_small#{m}_v#{v}_il#{i}")
    g.run
    g.interleave(true)
    g.vectorize(v)
  elsif v > 1
    g = Generator.new((n/v),1,v,v,a,
      "wht_vector#{v}", "apply_small#{m}_v#{v}")
    g.run
  elsif i > 1
    g = Generator.new(n,i,1,1,a,"wht_value", 
      "apply_small#{m}_il#{i}")
    g.run
    g.interleave(true)
  else
    g = Generator.new(n,1,1,1,a,"wht_value", 
      "apply_small#{m}")
    g.run
  end

  puts g
end
