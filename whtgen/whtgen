#!/usr/bin/env ruby

# whtgen.rb
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$

IDENT   = "  "

@stack  = []
@tmp    = 0

def wht_v(n,x,a,s,y,b,t,v)
  case v
    when 1 then wht_2(x,a,s,y,b,t,v)
    when 2 then wht_4_v2(n,x,a,s,y,b,t,v)
    else die "No WHT kernel for vector size #{v}"
  end
end

def wht_4_v2(n,x,a,s,y,b,t,v)
  t1,t2,t3,t4 = mk_tmp(4)
  @stack.push add(t1,x[a],x[a+s],v)
  @stack.push sub(t2,x[a],x[a+s],v)
  @stack.push shuf(t3,t1,t2,[0,0],v)
  @stack.push shuf(t4,t1,t2,[1,1],v)
  @stack.push add(t1,t3,t4,v)
  @stack.push sub(t2,t3,t4,v)
  @stack.push shuf(t3,t1,t2,[0,0],v)
  @stack.push shuf(t4,t1,t2,[1,1],v)
  y[b],y[b+t] = t3,t4
end

def wht_2(x,a,s,y,b,t,v)
  t1,t2 = mk_tmp(2)
  @stack.push add(t1,x[a],x[a+s],v)
  @stack.push sub(t2,x[a],x[a+s],v)
  y[b],y[b+t] = t1,t2
end

def wht(n,x,a,s,y,b,t,v)
  if n == 2*v
    wht_v(n,x,a,s,y,b,t,v)
  else
    z = {}
    m = n/2
    wht(m,x,a,s,z,b,t,v)
    wht(m,x,a+(m/v),s,z,b+(m/v),t,v)
    for i in 0 .. (m/v)-1 do
      wht_2(z,a+i,(m/v)*s,y,b+i,(m/v)*t,v)
    end
  end
end

def add(r,a,b,v)
  { :type => :add,   :out => r, :in => [a,b], :vsize => v }
end

def sub(r,a,b,v)
  { :type => :sub,   :out => r, :in => [a,b], :vsize => v }
end

def load(r,m,s,v)
  { :type => :load,  :out => r, :in => [m,s], :vsize => v }
end

def store(r,m,s,v)
  { :type => :store, :out => r, :in => [m,s], :vsize => v }
end

def shuf(r,a,b,m,v)
  # TODO assert m.size = v
  { :type => :shuf,  :out => r, :in => [a,b], :vsize => v, :mask => m}
end

def mk_tmp(k)
  a = []
  k.times do
    a << @tmp += 1
  end
  a
end

def scalar_stack_to_string p
  return "" if p.empty?
  x = p.shift
  r,a,b = x[:out],x[:in][0],x[:in][1]
  s = case x[:type]
    when :add   then "t#{r} = t#{a} + t#{b};\n"
    when :sub   then "t#{r} = t#{a} - t#{b};\n"
    when :load  then "t#{r} = #{a}[#{b}];\n"
    when :store then "#{a}[#{b}] = t#{r};\n"
    else "/* undefined. */\n"
  end
  IDENT + s + scalar_stack_to_string(p)
end

def vector_stack_to_string p
  return "" if p.empty?
  x = p.shift
  r,a,b,v,m = x[:out],x[:in][0],x[:in][1],x[:vsize],x[:mask]
  s = case x[:type]
    when :add   then "vadd#{v}(t#{r},t#{a},t#{b});\n"
    when :sub   then "vsub#{v}(t#{r},t#{a},t#{b});\n"
    when :load  then "vload#{v}(t#{r},#{a}[#{b}]);\n"
    when :store then "vstore#{v}(t#{r},#{a}[#{b}]);\n"
    when :shuf  then "vshuf#{v}(t#{r},t#{a},t#{b},[#{m.join(',')}]);\n"
    else "/* undefined. */\n"
  end
  IDENT + s + vector_stack_to_string(p)
end

def die(msg)
  puts msg
  exit 1
end

# Main entry point 

class Options
  require 'optparse'
  attr_reader :params
  def initialize
    @params = {}
    @params[:n] = nil
    @params[:v] = 1
    @options = OptionParser.new do |o|
      o.banner = "Usage: #{$0} [OPTIONS]"
      o.separator ""
      o.on("-h", "--help", 
        "Show this help message.") { die }

      o.on("-v", "--vector_size=SIZE", Integer,
        "Vector size.") { |x| @params[:v] = x.to_i }

      o.on("-n", "--wht_size=SIZE", Integer,
        "Size of WHT to unroll.") { |x| @params[:n] = x.to_i } 
    end
  end

  def die(msg = nil)
    puts @options.to_s 
    puts "\n#{msg}" unless msg.nil?
    exit
  end

  def parse(args)
    begin
      @options.parse!(args)
    rescue => e
      die(e.message)
    end

    die unless @params.has_key?(:n)
    die unless @params.has_key?(:v)
    unless @params[:n] > @params[:v]
      die("Size must be greater than vector size.")
    end
  end

end

opts = Options.new
opts.parse(ARGV)

n = opts.params[:n]
v = opts.params[:v]

x = {}
y = {}

(n/v).times do |i| 
  t = mk_tmp(1)
  x[i] = t
  @stack.push  load(t,"x",i*v,v)
end

wht(n,x,0,1,y,0,1,v)

(n/v).times do |i| 
  t = y[i] 
  @stack.push store(t,"x",i*v,v)
end

if v > 1
  type = "wht_vector#{v}" 
  name = "apply_small#{n}_v#{v}"
  body = vector_stack_to_string(@stack) 
else
  type = "wht_value"
  name = "apply_small#{n}"
  body = scalar_stack_to_string(@stack) 
end

header = "#include \"wht.h\"\n\n" +
         "void #{name}(Wht *W, long S, long D, wht_value *x)\n{\n"

decls = ""
@tmp.times do |i|
  decls += IDENT + type + " t#{i};\n"
end

puts header + decls + body + "}\n"
