/*
 * Copyright (c) 2007 Drexel University
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */


/**
 * \file rand.cxx
 * \author Michael Andrews
 *
 * \brief Interface to random tree generation
 */
extern "C" {
#include "wht.h"
}

#include "combin.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <math.h>

static void
usage() 
{
  printf("Usage: wht_rand -n SIZE [OPTIONS]\n");
  printf("    -h            Show this help message.\n");
  printf("    -v            Show build information.\n");
  printf("    -n SIZE       Total size of random composition.\n");
  printf("    -a MIN_F      Minimum number of factors in composition.\n");
  printf("    -b MAX_F      Maximum number of factors in composition.\n");
  printf("    -p MIN_E      Minimum element in composition.\n");
  printf("    -q MAX_E      Maximum element in composition.\n");
  printf("    -u UNSTRICT   Generate WHT trees that cannot be executed in current configuration.\n");
#if 0
  printf("    -t TYPE       Type of WHT to generate (DEFAULT \"general\").\n");
#endif
  exit(1);
}

int
main(int argc, char **argv)
{
  size_t wht_size, min_child, max_child, min_leaf, max_leaf;
  char *wht_type;
  bool strict;

  int c;

  wht_size = 0;

  opterr = 0;

  min_child = 1;
  max_child = MAX_SPLIT_NODES;
  min_leaf  = 1;
  max_leaf  = WHT_MAX_UNROLL;
  wht_type  = NULL;
  strict    = true;

  while ((c = getopt (argc, argv, "hvn:a:b:p:q:t:u")) != -1)
    switch (c) {
      case 'n':
        wht_size = atoi(optarg);
        break;
      case 'a':
        min_child = atoi(optarg);
        break;
      case 'b':
        max_child = atoi(optarg);
        break;
      case 'p':
        min_leaf = atoi(optarg);
        break;
      case 'q':
        max_leaf = atoi(optarg);
        break;
      case 't':
        wht_type = optarg;
        break;
      case 'u':
        strict = false;
        break;
      case 'h':
        usage();
      case 'v':
        wht_info();
        exit(0);
      default:
        usage();
    }

  if (wht_size == 0)
    usage();

  if (min_leaf < 1) {
    printf("-a MIN_E too small.\n");
    exit(1);
  }

  if ((min_leaf > WHT_MAX_UNROLL) && strict) {
    printf("-a MIN_E cannot be larger than %d.\n", WHT_MAX_UNROLL);
    exit(1);
  }

  if ((max_leaf > WHT_MAX_UNROLL) && strict) {
    printf("-b MAX_E cannot be larger than %d.\n", WHT_MAX_UNROLL);
    exit(1);
  }

  if (wht_type != NULL && (strcmp(wht_type, "general" ) != 0) 
                       && (strcmp(wht_type, "right"   ) != 0)) {
    printf("-t TYPE must be \"general\" or \"right\".\n");
    exit(1);
  }

  compos_node *root;
  Wht *W;

  srandom((unsigned int) (getpid() * M_PI));

  root = NULL;

  root = compos_tree_rand(wht_size, min_child, max_child, min_leaf, max_leaf);
#if 0
  if (wht_type == NULL || (strcmp(wht_type, "general") == 0))
    root = compos_tree_rand(wht_size, min_child, max_child, min_leaf, max_leaf);
  else if (strcmp(wht_type, "right") == 0)
    root = compos_tree_rand_right(wht_size, min_child, max_child, min_leaf, max_leaf);
#endif


  W = compos_tree_to_wht(root);
  assert(W->n == ((long) wht_size));
  printf("%s\n", W->to_string);

  compos_tree_free(root);
  wht_free(W);

  return 0;
}

#ifndef DOXYGEN_MAN_MODE
/**
\page wht_rand Generate a Random WHT Plan

\section _synopsis SYNOPSIS
wht_rand -n SIZE [OPTIONS]

\section _description DESCRIPTION

This program generates random WHT plans given a set of constraints. 
In the context of random generation we consider WHT plans to be trees.
To be specific, 
all trees generated by this program are Uniform Level, Bernoulli Recursive.  
That is, for each integer composition within the constraints, we assume that each is 
equally likely to occur.  If the integer composition can be factored into another 
integer composition, we recursively apply the algorithm.  
If the integer could be factored but could also remain as a leaf node, we flip a coin to 
determine if the algorithm should be recursively applied.

\verbatim
    -h            Show this help message.
    -v            Show build information.
    -n SIZE       Total size of random composition.
    -a MIN_F      Minimum number of factors in composition.
    -b MAX_F      Maximum number of factors in composition.
    -p MIN_E      Minimum element in composition.
    -q MAX_E      Maximum element in composition.
    -u UNSTRICT   Generate WHT trees that cannot be executed in current configuration.
\endverbatim

\section _examples EXAMPLES

Generate a random WHT plan of size 8 with a width of 2 (e.g a random binary tree of size 8).
\verbatim
wht_rand -n 8 -b 2
split[small[2],split[small[3],split[small[1],split[small[1],small[1]]]]]
\endverbatim

Generate a random WHT plan of size 17 with nodes of at least size 2 and at most size 4.
\verbatim
wht_rand -p 2 -q 4 -n 17
split[small[2],small[2],small[2],small[2],split[split[small[2],small[2]],split[small[2],small[3]]]]
\endverbatim

Generate a random WHT plan of size 25 with nodes of at least size 10.
\verbatim
wht_rand -p 10 -n 25 
-a MIN_E cannot be larger than 8.
\endverbatim

Since the package has not been configured for this large of a codelet, use the UNSTRICT flag.
\verbatim
wht_rand -p 10 -n 25 -u
split[small[10],small[15]]
\endverbatim


*/
#endif/*DOXYGEN_MAN_MODE*/
