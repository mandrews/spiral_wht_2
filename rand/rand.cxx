extern "C" {
#include "wht.h"
}

#include "combin.h"

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <math.h>

static void
usage() 
{
  printf("Usage: wht_rand -n SIZE [OPTIONS]\n");
  printf("    -h            Show this help message.\n");
  printf("    -v            Show build information.\n");
  printf("    -n SIZE       Total size of random composition.\n");
  printf("    -a MIN        Minimum number of factors in composition.\n");
  printf("    -b MAX        Maximum number of factors in composition.\n");
  printf("    -p MIN        Minimum element in composition.\n");
  printf("    -q MAX        Maximum element in composition.\n");
  printf("    -t TYPE       Type of WHT to generate (DEFAULT \"general\").\n");
  exit(1);
}

int
main(int argc, char **argv)
{
  size_t wht_size, min_child, max_child, min_leaf, max_leaf;
  char *wht_type;

  int c;

  wht_size = 0;

  opterr = 0;

  min_child = 1;
  max_child = MAX_SPLIT_NODES;
  min_leaf  = 1;
  max_leaf  = WHT_MAX_UNROLL;
  wht_type  = NULL;

  while ((c = getopt (argc, argv, "hvn:a:b:p:q:t:")) != -1)
    switch (c) {
      case 'n':
        wht_size = atoi(optarg);
        break;
      case 'a':
        min_child = atoi(optarg);
        break;
      case 'b':
        max_child = atoi(optarg);
        break;
      case 'p':
        min_leaf = atoi(optarg);
        break;
      case 'q':
        max_leaf = atoi(optarg);
        break;
      case 't':
        wht_type = optarg;
        break;
      case 'h':
        usage();
      case 'v':
        wht_info();
        exit(0);
      default:
        usage();
    }

  if (wht_size == 0)
    usage();

  if (min_leaf < 1) {
    printf("-a MIN_NODE too small.\n");
    exit(1);
  }

  if (max_leaf > WHT_MAX_UNROLL) {
    printf("-b MAX_NODE cannot be larger than %d.\n", WHT_MAX_UNROLL);
    exit(1);
  }

  if (wht_type != NULL && (strcmp(wht_type, "general" ) != 0) 
                       && (strcmp(wht_type, "right"   ) != 0)) {
    printf("-t TYPE must be \"general\" or \"right\".\n");
    exit(1);
  }

  compos_node *root;
  char *buf;

  srandom((unsigned int) (getpid() * M_PI));

  root = NULL;

  if (wht_type == NULL || (strcmp(wht_type, "general") == 0))
    root = compos_tree_rand(wht_size, min_child, max_child, min_leaf, max_leaf);
  else if (strcmp(wht_type, "right") == 0)
    root = compos_tree_rand_right(wht_size, min_child, max_child, min_leaf, max_leaf);

  buf = compos_tree_to_string(root);
  printf("%s\n", buf);

  compos_tree_free(root);
  free(buf);

  return 0;
}

#ifndef DOXYGEN_MAN_MODE
/**
\page wht_rand Generate a Random WHT Plan

\section _synopsis SYNOPSIS
wht_rand -n SIZE [OPTIONS]

\section _description DESCRIPTION

This program generates random WHT plans given a set of constraints. 
In the context of random generation we consider WHT plans to be trees.
To be specific, 
all trees generated by this program are Uniform Level, Bernoulli Recursive.  
That is, for each integer composition within the constraints, we assume that each is 
equally likely to occur.  If the integer composition can be factored into another 
integer composition, we recursively apply the algorithm.  
If the integer could be factored but could also remain as a leaf node, we flip a coin to 
determine if the algorithm should be recursively applied.

\verbatim
    -h            Show this help message.
    -v            Show build information.
    -n SIZE       Total size of random composition.
    -a MIN        Minimum number of factors in composition.
    -b MAX        Maximum number of factors in composition.
    -p MIN        Minimum element in composition.
    -q MAX        Maximum element in composition.
    -t TYPE       Type of WHT to generate (DEFAULT "general").
\endverbatim

\section _examples EXAMPLES

Generate a randome WHT plan of size 8 with a width of 2 (e.g a random binary tree of size 8).
\verbatim
wht_rand -n 8 -b 2
split[small[2],split[small[3],split[small[1],split[small[1],small[1]]]]]
\endverbatim

*/
#endif/*DOXYGEN_MAN_MODE*/
