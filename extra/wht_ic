#!/usr/bin/env ruby

# TODO 
# Back port path idea to wht_dp
# Refactor calc_coeff
# Look into discrepancy between all and papi

$LOAD_PATH << File.dirname(__FILE__) 

require "utils"

require "narray"
require 'tempfile'
require 'digest/md5'

SCRIPT_PATH       = File.dirname(__FILE__) 
SCRIPT_NAME       = 'wht_ic'

DEFAULT_PARAMS    = {
  :wht            => nil,
  :op             => 'papi',
  :type           => 'all',
  :refresh        => false,
  :lib            => find_file('libwht.a'),
  :count          => find_file('wht_count'),
  :measure        => find_file('wht_measure'),
}

OPS = [
  'addsd',
  'subsd',
  'addpd',
  'subpd',
  'addss',
  'subss',
  'addps',
  'subps',
  'shufpd',
  'shufps',
  'unpckhpd',
  'unpcklpd',
  'unpckhps',
  'unpcklps',
  'movsd' ,
  'movapd' ,
  'movss' ,
  'movaps' ,
  'movhpd',
  'movlpd',
  'movhps',
  'movlps',
  'movhlps',
  'movlhps',
# Extra
  'lea',
  'shl',
  'xor',
  'push',
  'pop',
  'nop',
  'retq',
  'mov',
  'add',
  'sub',
  'imul'
]

class Opts < Options
  def initialize
    @params  = DEFAULT_PARAMS
    @options = OptionParser.new do |o|
      o.banner = "Usage: #{SCRIPT_NAME} [OPTIONS]"
      o.separator ""

      o.on("-h", "--help", 
        "Show this help message.") { 
        die }

      o.on("-w", "--plan=WHT", String,
        "Generate counts for WHT plan.") { |x|
         @params[:wht] = x }

      o.on("-o", "--op=OP", String,
        "Count OP codes.") { |x|
         @params[:op] = x }

      o.on("-v", "--verbose", 
        "Show non-essential information.") {
        @params[:verbose] = true }

      o.on("-t", "--type=TYPE", ['all', 'reg', 'mem'],
        "Select op type to count (all, reg, mem)") { |x|
         @params[:type] = x }

      o.on("-X", "--refresh", 
        "Refresh cached data.") { |x|
         @params[:refresh] = true }
    end
  end
end

class VectorSpace
  attr_accessor :basis, :span
  attr_accessor :n, :k, :v

  class Basis < Array
    attr_accessor :file
    def initialize
      @file  = nil
    end

    def path
      @file.path
    end

    def remove
      @file.unlink
    end
  end

  class Span < Array; end

  def initialize(n,k,v)
    @n,@k,@v = n,k,v
    @basis = Basis.new
    @span  = Span.new

    construct!
    save
  end

  def construct!
    for i in (1..n) 
      @basis << "small[#{i}]"
      @span  << "small[#{i}]"
    end

    simd_extensions_small

    @basis << "split_alpha"
    @basis << "split_beta_1"
    @basis << "split_beta_2"
    @basis << "split_beta_3"

    @span  << "split[small[2],small[2],small[2],small[2]]"
    @span  << "split[split[small[2],small[2],small[2]],small[2]]"
    @span  << "split[small[2],split[small[2],small[2],small[2]]]"
    @span  << "split[split[small[2],small[2]],split[small[2],small[2]]]"

    simd_extensions_split
  end

  def save
    @basis.file = Tempfile.new("wht")

    fd = @basis.file.open 
    @basis.each { |x| fd.puts(x) }
    fd.close
  end

  def simd_extensions_small
    return if @v < 1

    p = (Math.log(v) / Math.log(2)).ceil 
    q = (Math.log(k) / Math.log(2)).ceil 

    for i in (p+1..n) 
      @basis << "smallv(#{v},0)[#{i}]"
      @basis << "smallv(#{v},1)[#{i}]"
      @span  << "smallv(#{v},0)[#{i}]"
      @span  << "smallv(#{v},1)[#{i}]"
    end

    for i in (1..n)
    for j in (p..q)
      je = (1 << j)
      @basis << "smallv(#{v},#{je},0)[#{i}]"
      @basis << "smallv(#{v},#{je},1)[#{i}]"
      @span  << "splitil[smallv(#{v},#{je},0)[#{i}],small[#{q+1}]]"
      @span  << "splitil[smallv(#{v},#{je},1)[#{i}],small[#{q+1}]]"
    end
    end

    @basis << "smallv(#{v})[#{p}]"
    @span  << "splitv(#{v})[smallv(#{v})[#{p}],smallv(#{v},#{v},1)[2]]"

  end

  def simd_extensions_split
    return if @v < 1

    p = (Math.log(v) / Math.log(2)).ceil 
    q = (Math.log(k) / Math.log(2)).ceil 

    @basis << "splitil_alpha"
    @basis << "splitil_beta_1"
    @basis << "splitil_beta_2"
    @basis << "splitil_beta_3"

    @span  << ( "splitil[" +
      "smallv(#{v},#{v},1)[2]," +
      "smallv(#{v},#{v},1)[2]," +
      "smallv(#{v},#{v},1)[2]," +
      "smallv(#{v},1)[#{p+1}]]" )
    @span  << ( "splitil[" +
      "splitil[" +
        "smallv(#{v},#{v},0)[2]," +
        "smallv(#{v},#{v},0)[2]," +
        "smallv(#{v},0)[#{p+1}]]" +
      ",smallv(#{v},1)[#{p+1}]]" )
    @span  << ( "splitil[" +
      "smallv(#{v},#{v},1)[2]," +
      "splitil[" +
        "smallv(#{v},#{v},1)[2]," +
        "smallv(#{v},#{v},1)[#{p+1}]," +
        "smallv(#{v},1)[#{p+1}]]]" )
    @span  << ( "splitil[" +
      "splitil[" +
        "smallv(#{v},#{v},0)[2]," +
        "smallv(#{v},0)[#{p+1}]]," +
      "splitil[" +
        "smallv(#{v},#{v},1)[2]," +
        "smallv(#{v},1)[#{p+1}]]]" )
  end
end

def calc_papi(space)
  basis = space.basis
  span =  space.span 

  a = NMatrix.float(span.length,span.length)
  b = NVector.float(span.length)

  i = 0
  for vector in span
    begin
    ai = count({
      '-w' => "'#{vector}'", 
      '-b' => basis.path })

    bi = measure({ 
      '-w' => "'#{vector}'", 
      '-m' => 'PAPI_TOT_INS', 
      '-n' => 1,
    }, '-c')
    rescue 
      puts "Skipping #{vector}"
      next
    end

    a[0,i] = ai.values
    b[i] = bi

    i += 1
  end

  x = a.lu.solve(b.transpose)

  hash = {}
  basis.each_with_index do |b,i|
    hash[b] = x[i]
  end
  hash
end

def disassemble(lib)
  procs = {}

  cmd = "objdump -d #{lib}"
  IO.popen(cmd) do |fd|
    grab = false
    while line = fd.gets
      line.chomp!

      if line =~ /<(apply.*?)>:/
        grab = true
        name = $1
        procs[name] = []
      end

      procs[name] << line if grab

      grab = false if line =~ /^\n$/
    end
  end

  procs
end

def calc_coeffs(lib, space, refresh=false)
  md5 = Digest::MD5.hexdigest(IO::readlines(lib, nil).first)
  tmp = "/tmp/#{md5}"

  if File.exists?(tmp) and not refresh
    return File.open(tmp) do |fd|
      load_data(fd)
    end
  end

  table = { 'reg' => {}, 'mem' => {}, 'all' => {} }

  procs = disassemble(lib)
  procs.each do |decl,body|

    name = case decl
      when /small(\d+)$/                    then "small[#{$1}]"
      when /small(\d+)_v(\d+)_v$/           then "smallv(#{$2})[#{$1}]"
      when /small(\d+)_v(\d+)$/             then "smallv(#{$2},0)[#{$1}]"
      when /small(\d+)_v(\d+)_a$/           then "smallv(#{$2},1)[#{$1}]"
      when /small(\d+)_v(\d+)_il(\d+)$/     then "smallv(#{$2},#{$3},0)[#{$1}]"
      when /small(\d+)_v(\d+)_il(\d+)_a$/   then "smallv(#{$2},#{$3},1)[#{$1}]"
      when /small(\d+)_il(\d+)$/            then "smallil(#{$2})[#{$1}]"
      else nil
    end

    next if name.nil?

    body.each do |line|
      cols = line.split(/\s+/)

      if OPS.include?(cols.last)
        op = cols.last
        va = ""
      else
        va = cols.pop
        op = cols.pop
      end

      next unless OPS.include?(op)

      table['reg'][op] ||= {}
      table['mem'][op] ||= {}
      table['all'][op] ||= {}

      if va =~ /\(.*\)/
        table['mem'][op][name] ||= 0
        table['mem'][op][name] += 1 
      else
        table['reg'][op][name] ||= 0
        table['reg'][op][name] += 1 
      end

      table['all'][op][name] ||= 0
      table['all'][op][name] += 1 

      table['all']['all'] ||= {}
      table['all']['all'][name] ||= 0
      table['all']['all'][name] += 1 
    end
  end

  table['all']['papi'] = calc_papi(space)

  for x in [ 'split', 'splitil', 'splitv' ] do
    for y in [ 'alpha', 'beta_1', 'beta_2', 'beta_3' ] do
      s = "#{x}_#{y}"
      table['all'][s] = { s => 1 }
    end
  end

  table['mem'].delete_if { |k,v| v.empty? }
  table['reg'].delete_if { |k,v| v.empty? }
  table['all'].delete_if { |k,v| v.empty? }

  File.open(tmp,'w+') do |fd|
    save_data(fd, table)
  end

  table
end

def coeff_to_nvector(space, coeff)
  x = NVector.float(space.basis.length)
  i = 0
  space.basis.each do |elem|
    x[i] = coeff[elem] || 0
    i += 1
  end
  x
end

alias :count_to_nvector :coeff_to_nvector 

if $0 == __FILE__ # Main Entry Point

  opts = Opts.new
  opts.parse(ARGV)

  if opts.params[:wht].nil?
    opts.params[:wht] = $stdin.gets.chomp
  end

  if opts.params[:wht].nil?
    opts.die("Need to specify WHT plan")
  end

  if opts.params[:op].nil?
    opts.die("Need to specify OP Code")
  end

  env = load_runtime_env

  n = env['max_unroll']
  k = env['max_interleave']
  v = env['vector_size']

  space = VectorSpace.new(n,k,v)

  coeff_table = calc_coeffs(opts.params[:lib], space, opts.params[:refresh])

  type, op = opts.params[:type], opts.params[:op]

  op_coeff = coeff_table[type][op] 

  if op_coeff.nil?
    $stderr.puts "No counts for #{op} with type #{type}"
    $stdout.puts "0"
    exit
  end

  begin
    codelet_count = count({
      '-w' => "'#{opts.params[:wht]}'", 
      '-b' => space.basis.path })
  rescue Exception => e
    puts e
    exit
  end

  space.basis.remove

  x = coeff_to_nvector(space, op_coeff)
  y = count_to_nvector(space, codelet_count)

  puts (x .* y).floor
end

