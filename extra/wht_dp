#!/usr/bin/env ruby

# wht_dp
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$
#

SCRIPT_PATH       = File.dirname(__FILE__) 
SCRIPT_NAME       = 'wht_dp'

$LOAD_PATH << File.dirname(__FILE__) 

require "utils"

DEFAULT_PARAMS    = {
  :min_size       => 1,
  :max_size       => 15,
  :max_children   => 2,
  :max_cache      => 2,
  :max_depth      => INF,
  :max_extent     => INF,
  :shapes         => ['right', 'left', 'iterative', 'balanced', 'mixed'],
  :measure        => SCRIPT_PATH + '/wht_measure',
  :best_plans     => SCRIPT_PATH + '/../share/wht_best_plans.txt',
  :pedantic       => false,
  :verbose        => false,
  :rules          => nil,
  :smalls         => [],
  :splits         => [],
  :log            => "/dev/null",
  :worst          => false,
}

class Options
  require 'optparse'
  attr_reader :params
  def initialize
    @params  = DEFAULT_PARAMS
    @options = OptionParser.new do |o|
      o.banner = "Usage: #{SCRIPT_NAME} [OPTIONS]"
      o.separator ""
      o.on("-h", "--help", 
        "Show this help message.") { 
        die }

      o.on("-v", "--verbose", 
        "Show non-essential information.") {
        @params[:verbose] = true }

      o.on("-a", "--min-size=SIZE", Integer,
        "Start the search at size 2^SIZE.") { |x|
        @params[:min_size] = x }

      o.on("-b", "--max-size=SIZE", Integer,
        "Stop the search at size 2^SIZE.") { |x|
        @params[:max_size] = x }

      o.on("-k", "--max-children=CHILDREN", Integer,
        "Maximum number of children to allow on a split node.") { |x|
        @params[:max_children] = x }

      o.on("--max-depth=DEPTH", Integer,
        "Maximum depth of WHT trees.") { |x|
        @params[:max_depth] = x }

      o.on("--max-extent=DEPTH", Integer,
        "Maximum extent of WHT trees.") { |x|
        @params[:max_extent] = x }

      o.on("--shapes=S1,S2,..,SN", Array,
        "Possible shapes of WHT trees.") { |x|
        @params[:shapes] = x }

      o.on("-x", "--max-cache=SIZE", Integer,
        "Maximum number of sub problems to store.") { |x|
        @params[:max_cache] = x }

      o.on("-m", "--measure=FILE", 
        "Program to measure peformance of WHT plan.") { |x|
         @params[:measure] = x }

      o.on("-r", "--rule=SCRIPT", String,
        "Search using a rule script.") { |x|
         @params[:rules] = x }

      o.on("--splits=S1;S2;...;SN", String,
        "Search using split rules.") { |x|
         @params[:splits] = x.split(/\s*;\s*/) }

      o.on("--smalls=S1;S2;...;SN", String,
        "Search using small rules.") { |x|
         @params[:smalls] = x.split(/\s*;\s*/) }

      o.on("-p", "--pedantic", 
        "Search over both builtins and rules.") { |x|
         @params[:pedantic] = true }

      o.on("-f", "--best-plans=FILE", String,
        "File to load/store the best plans found by dynamic programming.") { |x|
         @params[:best_plans] = x }

      o.on("-d", "--log=FILE", String,
        "File to log to.") { |x|
         @params[:log] = x }

      o.on("-w", "--worst", 
        "Search for the worst trees instead of the best.") { 
         @params[:worst] = true  }
    end
  end

  def die(msg = nil)
    puts @options.to_s 
    puts "\n#{msg}" unless msg.nil?
    exit
  end

  def parse(args)
    begin
      @options.parse!(args)
    rescue => e
      die(e.message)
    end
  end
end

class Search
  attr_accessor :debug
  def initialize(params)
    @min_size       = params[:min_size]
    @max_size       = params[:max_size]
    @max_children   = params[:max_children]
    @max_cache      = params[:max_cache]
    @max_depth      = params[:max_depth]
    @max_extent     = params[:max_extent]
    @shapes         = params[:shapes]
    @measure        = params[:measure]
    @max_leaf       = params[:max_leaf]
    @rules          = params[:rules]
    @splits         = params[:splits] + [ "split" ]
    @smalls         = params[:smalls] + [ "small" ]
    @debug          = params[:debug]
    @pedantic       = params[:pedantic]
    @worst          = params[:worst]

    @splits.uniq!
    @smalls.uniq!

    if not @rules.nil? and ((@smalls.length > 1) or (@splits.length > 1))
      puts "Cannot use WHT tree rule and codelet rules"
      exit
    end

    @log  = File.open(params[:log],'a')

    @best = Array.new(@max_size)

    if @worst
      @search_relation = lambda { |x,y| x > y }
      @search_initial  = -INF
    else
      @search_relation = lambda { |x,y| x < y }
      @search_initial  = INF
    end

    for size in 1 .. @max_size do 
      @best[size] ||= [ { 'time' => @search_initial, 'plan' => nil, 'id' => size} ]
    end

  end

  def log(msg)
    puts msg 
    @log.puts msg
  end

  def debug(msg)
    puts msg if @debug
    @log.puts msg
  end

  def best=(best)
    # Add a 0 element (makes indexing easier)
    best.unshift([{'id' => 0, 'time' => @search_initial, 'plan' => nil}]) 

    best.each_index do |i|
      @best[i] = best[i] 
    end
  end

  def best
    @best.shift # Remove 0 element

    @best.each do |y|
      y.delete_if { |x| x.nil? }
      y.delete_if { |x| x['time'] == @search_initial } 
      y.delete_if { |x| x['plan'].nil? } 
    end

    return @best
  end

  def run
    t0 = Time.now
    for size in @min_size .. @max_size do 
      debug("size #{size}")
      find(size)
    end
    t1 = Time.now
    log("Total: #{t1 - t0}") 
  end

  def apply(plan)
    cmd = "#{@rules} -w '#{plan}'"
    debug("Executing #{cmd}")

    out = nil
    IO.popen(cmd) do |fd|
      out = fd.gets
    end

    if out.nil? 
      log("Could not read: #{cmd}") 
      return nil
    else 
      return out.chomp
    end
  end

  def classify(plan)
    cmd = "#{SCRIPT_PATH}/../bin/wht_classify -w '#{plan}'"
    debug("Executing #{cmd}")

    out = 0
    IO.popen(cmd) do |fd|
      out = fd.readlines
    end
  
    h = {}
    out.each do |line|
      k,v = line.split(/\s*:\s*/)
      h[k] = v.chomp
    end
  
    log("Could not read: #{cmd}") if h.empty?  
  
    return h
  end

  def vet(plan)
    cmd = "#{SCRIPT_PATH}/../bin/wht_attach -w '#{plan}'"
    debug("Executing #{cmd}")

    out = nil
    IO.popen(cmd) do |fd|
      out = fd.gets
    end

    if out.nil? 
      log("Could not read: #{cmd}") 
      return nil
    else 
      return out.chomp
    end
  end

  def measure(plan)
    cmd = "#{@measure} -w '#{plan}'"
    debug("Executing #{cmd}")

    out = 0
    IO.popen(cmd) do |fd|
      out = fd.gets
    end

    if out.nil? or out.to_f.zero?
      debug("Could not read: #{cmd}") 
      return @search_initial
    else 
      return out.to_f
    end
  end

  def find(size)
    plans = []

    g_cp_n(size, 1, @max_children) do |zp|
      next if zp.first == size and size > @max_leaf
      plans += zp_to_plans(zp)
    end

    unless @rules.nil?
      new_plans = plans.map { |plan| apply(plan) }

      if @pedantic 
        plans += new_plans
      else
        plans = new_plans
      end
    end

    log("Space size for #{size}: #{plans.size}")

    plans.map! { |x| vet(x) }
    plans.uniq!

    plans.reject! do |p|
      attrs = classify(p)
      attrs['depth'].to_i > @max_depth or
        (attrs['extent'].to_i > @max_extent) or
        (not @shapes.include?(attrs['shape']))
    end

    log("Subspace size for #{size}: #{plans.size}")

    plans.uniq.each do |p|
      t = measure(p)

      @best[size].each do |x| 
        tp = x['time']
        if @search_relation.call(t,tp)

          if @best[size].size >= @max_cache
            @best[size].delete(x) # Remove old best
          end

          log "New Best for #{size} with T=#{t} (T'=#{tp}): #{p}"
          @best[size] << { 'id' => size, 'time' => t, 'plan' => p }
          break
        end
      end
    end
  end

  def find_best(size)
    find(size) if @best[size].empty?

    plans = []

    @best[size].sort! { |x,y| x['time'] <=> y['time'] }

    @best[size].each do |x|
      next if x['time'] == @search_initial
      next if x['plan'].nil?
      plans << x['plan']
      break if plans.size >= @max_cache
    end

    return plans
  end

  def zp_to_plans(zp)
    tmp = []
    zp.each do |z|
      if z > @max_leaf
        tmp << find_best(z)  
      else
        s = []
        @smalls.each do |id|
          s << "#{id}[#{z}]"
        end
        tmp << s
      end
    end

    plans = []
    combinations(tmp).each do |s|
      s = s.to_a
      if s.size > 1
        @splits.each do |id|
          plans << "#{id}[" + s.join(',') + "]"
        end
      else
        plans << s.first
      end
    end

    return plans
  end

end

# Generate (enumerate) all k combinations of n
# See http://home.att.net/~srschmitt/script_combinations.html
def g_k_cb_n(n,k)
  a = (1..k).to_a

  loop do
    yield a

    i = k - 1
    while a[i] == (n - k + i + 1) do
      i -= 1
    end

    return if (i < 0)

    a[i] += 1

    for j in i+1 .. k-1 do
      a[j] = a[i] + j - i
    end
  end
end

# Generate (enumerate) all k combinations of n
# given that the plans are rightmost
# See above
def rightmost(a,max)
  b = a.dup
  b.pop # Do not consider last element
  c = b.select { |x| x <= max }
  return (c.size == b.size)
end

# Map a combination to a composition
# Idea from Dr. Johnson
# see http://en.wikipedia.org/wiki/Combinadic
def map_cb_to_cp(n, cb)
  m, i = 0, 0
  cp = Array.new(cb.size)
  cb.each do |x|
    cp[i] = x - m
    m = x
    i += 1
  end
  cp[i] = n - m
  cp
end

# Generate (enumerate) all k-way compositions of n forall k in a..b
def g_cp_n(n, a, b)
  max = [n, b].min
  a.upto(max) do |k|
    g_k_cb_n(n-1,k-1) do |cb|
      yield map_cb_to_cp(n,cb)
    end
  end
end

def combinations(a)
  return a.first if a.size == 1

  h = a.shift
  t = combinations(a)

  all = []
  t.each do |y|
    h.each do |x|
      if y.class == Array
        all << [x] + y
      else
        all << [x] + [y]
      end
    end
  end

  all
end

if $0 == __FILE__ # Main Entry Point
  opts = Options.new
  opts.parse(ARGV)

  unless File.exists?(opts.params[:measure].split.first)
    opts.die("Could find measure #{opts.params[:measure]}")
  end

  unless File.exists?(opts.params[:best_plans])
    File.new(opts.params[:best_plans], "w+")
  end

  unless File.writable?(opts.params[:best_plans])
    opts.die("Could not write to best_plans #{opts.params[:best_plans]}")
  end

  env = load_runtime_env(opts.params[:measure].split.first)

  o = opts.params.dup

  o[:max_leaf] = env['max_unroll']

  dp = Search.new(o)

  file  = opts.params[:best_plans] 
  plans = []

  File.open(file,'r') do |fd|
    plans = load_data(fd) 
  end

  dp.best = plans || []

  begin
    dp.run
  rescue Interrupt
    puts "Saving ... "
  ensure
    File.open(file,'w+') do |fd|
      save_data(fd, dp.best)
    end
  end

end

