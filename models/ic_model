#!/usr/bin/env ruby
#
# ic_model
#
# Author: Michael Andrews <mjand@drexel.edu>
# $Id$

require 'rdparser'

def zpt_to_plan(zpt)
  return "small[#{zpt}]" unless zpt.class == Array

  a = []
  zpt.each do |z|
    a << zpt_to_plan(z)
  end
  return "split[" + a.join(',') + "]"
end

def plan_to_zpt(plan)
  root = nil
  parser = RDParser.new do
    token(/\s+/) # Ignore whitespace
    token(/\d+/) { |m| m.to_i }
    token(/\[/)  { |n| n.to_s }
    token(/\]/)  { |n| n.to_s }
    token(/,/)   { |n| n.to_s }
    token(/\w+/) { |m| m.to_s }

    start :node do
      match(:split) { |n| n }
      match(:small) { |n| n }
    end

    rule :split do
      match("split", '[', :nodes, ']') { |_,_,ns,_| ns  }
    end

    rule :small do
      match("small", '[', Integer , ']') { |_,_,z,_| z }
    end

    rule :nodes do
      match(:node, ',', :nodes) { |n,_,ns| [n] + ns }
      match(:node) { |n| [n] }
    end
  end

  root = parser.parse(plan)
  root

end

def zpt_to_size(zpt)
  if zpt.class == Array
    sum = 0
    zpt.flatten.each { |x| sum += x }
    sum
  else
    zpt
  end
end

class Array
  def pointwise_plus(a)
    self.each_index do |i|
      self[i] += a[i]
    end
  end

  def scalar_mult(a)
    self.each_index do |i|
      self[i] *= a
    end
  end
  
  def count(x)
    t = self.select { |y| y == x }
    t.length
  end
end

OVERHEAD = 237

def zpt_measure(zpt)
  plan = zpt_to_plan(zpt)
  `../measure/papi/wht_measure -w '#{plan}' -m TOT_INS 2> /dev/null`.to_i * 1.0 - OVERHEAD
end

def zpt_real_count(zpt)
  plan = zpt_to_plan(zpt)
  out = `../wht/wht_verify -w '#{plan}' 2>&1`.split("\n")
  [ out.count("a_0"), 
    out.count("b_1"),
    out.count("b_2"),
    out.count("b_3"),
    out.count("s_1"),
    out.count("s_2"),
    out.count("s_3"),
    out.count("s_4")
  ]
end

def an(zpt)
  return 0 unless zpt.class == Array

  count = 1
  n = zpt_to_size(zpt)
  zpt.each do |z|
    ni = zpt_to_size(z)
    count += 2**(n - ni) * an(z)
  end
  count
end

def al(zpt, l)
  if zpt.class == Array
    vl = zpt.flatten.count(l)
    nn = zpt_to_size(zpt)
    vl * (2**(nn - l))
  else
    zpt == l ? 1 : 0
  end
end

def l1(zpt)
  return 0 unless zpt.class == Array

  t = zpt.length

  count = t
  n = zpt_to_size(zpt)
  zpt.each do |z|
    ni = zpt_to_size(z)
    count += 2**(n - ni) * l1(z)
  end
  count
end

def l2(zpt)
  return 0 unless zpt.class == Array

  count = 0
  nn = zpt_to_size(zpt)
  nj = 0
  zpt.each do |z|
    ni = zpt_to_size(z)
    count += 2**(nn - ni) * l2(z)
    count += 2**(nj)
    nj += ni
  end
  count
end

def l3(zpt)
  return 0 unless zpt.class == Array

  count = 0
  nn = zpt_to_size(zpt)
  zpt.each do |z|
    ni = zpt_to_size(z)
    count += 2**(nn - ni) * l3(z)
    count += 2**(nn - ni)
  end
  count
end

def zpt_eqn_count(zpt)
  [ an(zpt), l1(zpt), l2(zpt), l3(zpt), 
    al(zpt,1), al(zpt,2), al(zpt,3), al(zpt,4) ]
end

def zpt_cost(zpt, coeff)
  count = zpt_eqn_count(zpt)
  cost = 0
  count.each_index do |i|
    cost += count[i] * coeff[i]
  end
  cost
end

def collect_model
  x, y = [], []

  for n in 1 .. 8 do
    100.times do
      plan = `../utils/wht_randtree -n #{n} -q 4`.chomp
      zpt = plan_to_zpt(plan)
      count = zpt_eqn_count(zpt)
      next if x.include?(count)
      real  = zpt_measure(zpt)
      x << count
      y << real
    end
  end

  [x,y]
end

# NOTE counted using objdump and 'stepi' wrt inner for loops
COEFF1 = [ 24.0, 20.0, 15.0, 25.0, 8.0, 23.0, 67.0, 189.0]

# obtained via least squares error
# if issparse(A), R = qr(A); else R = triu(qr(A)); end
# x = R\(R'\(A'*b));
# r = b - A*x;
# e = R\(R'\(A'*r));
# x = x + e;
COEFF2 = [ 25.0, 18.0, 9.0, 19.0, 8.0, 25.0, 65.0, 185.0 ]

if $0 == __FILE__ # Main Entry Point
  mode = :MODEL

  if mode == :MODEL
    plan = $stdin.readline.chomp
    puts plan
    zpt = plan_to_zpt(plan)

    t0 = Time.now
    m0 = zpt_cost(zpt, COEFF1)
    t1 = Time.now
    m1 = zpt_cost(zpt, COEFF2)
    t2 = Time.now
    m2 = zpt_measure(zpt)
    t3 = Time.now

    puts "model0 #{m0} (#{t1 - t0} s)"
    puts "model1 #{m1} (#{t2 - t1} s)"
    puts "actual #{m2} (#{t3 - t2} s)"
    puts "rerror0 #{(m2 - m0).abs / m0}"
    puts "rerror1 #{(m2 - m1).abs / m1}"

  elsif mode == :COLLECT
    x,y = collect_model

    x.map! { |xi| xi.join(' ') }
    
    puts x.join("\n")
    puts
    puts y.join(' ')
  end

end

